<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>白话协程之极简协程库分析 | Deep In Thinking | Just do it</title>

  
  <meta name="author" content="dpthinker">
  

  
  <meta name="description" content="“Talk is cheap. Show me the code.”   ― Linus Torvalds.

在上篇文章，我们介绍了协程的基本概念，现在我们借用云风设计和实现的C协程库，对协程进行更深入剖析，相信这篇文章可以让大家更深入更清晰了解协程本质。
一、极简协程库在github上搜索coroutine，第一个仓便是cloudwu/coroutine，简单看后发现设计极简，代码相当的少，是用来研究协程的绝佳例子。
整个库只有两个文件：一个头文件coroutine.h和一个实现文件coroutine.c，总共191行代码。
1-------------------------------------------------------------------------------2Language                     files          blank        comment           code3-------------------------------------------------------------------------------4C                                1             17              0            1755C/C++ Header                     1              6              0             166-------------------------------------------------------------------------------7SUM:                             2             23              0            1918-------------------------------------------------------------------------------

cloudwu/coroutine设计的是Asymmetric coroutine，所谓Asymmetric coroutine就是提供了两个接口（invoke和suspend）用于协程调度。对应的，Symmetric coroutine就是提供了一种切换接口的协程。">
  

  
  
  <meta name="keywords" content="协程,编程语言">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="白话协程之极简协程库分析"/>

  <meta property="og:site_name" content="Deep In Thinking"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Deep In Thinking" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Deep In Thinking</a>
    </h1>
    <p class="site-description">Just do it</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>白话协程之极简协程库分析</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/02/16/coroutine-talking-code-ananlyze/" rel="bookmark">
        <time class="entry-date published" datetime="2020-02-16T10:56:14.000Z">
          2020-02-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p> “Talk is cheap. Show me the code.”   ― Linus Torvalds.</p>
</blockquote>
<p>在上篇文章，我们介绍了协程的基本概念，现在我们借用云风设计和实现的C协程库，对协程进行更深入剖析，相信这篇文章可以让大家更深入更清晰了解协程本质。</p>
<h2 id="一、极简协程库"><a href="#一、极简协程库" class="headerlink" title="一、极简协程库"></a>一、极简协程库</h2><p>在github上搜索<code>coroutine</code>，第一个仓便是<a href="https://github.com/cloudwu" target="_blank" rel="noopener">cloudwu</a>/<strong><a href="https://github.com/cloudwu/coroutine" target="_blank" rel="noopener">coroutine</a></strong>，简单看后发现设计极简，代码相当的少，是用来研究协程的绝佳例子。</p>
<p>整个库只有两个文件：一个头文件<code>coroutine.h</code>和一个实现文件<code>coroutine.c</code>，总共<strong>191行</strong>代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Language                     files          blank        comment           code</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">C                                1             17              0            175</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">C/C++ Header                     1              6              0             16</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------------</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">SUM:                             2             23              0            191</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------------</span></pre></td></tr></table></figure>

<p><code>cloudwu/coroutine</code>设计的是<code>Asymmetric coroutine</code>，所谓<code>Asymmetric coroutine</code>就是提供了两个接口（<code>invoke</code>和<code>suspend</code>）用于协程调度。对应的，<code>Symmetric coroutine</code>就是提供了一种切换接口的协程。</p>
<a id="more"></a> 

<blockquote>
<p>A well-known classification of coroutines concerns the control-transfer operations that are provided and distinguishes the concepts of symmetric and asymmetric coroutines. <strong>Symmetric coroutine</strong> facilities provide a <strong>single control-transfer operation</strong> that allows coroutines to <strong>explicitly pass control between themselves</strong>. <strong>Asymmetric coroutine</strong> mechanisms (more commonly denoted as semi-symmetric or semi coroutines) provide <strong>two control-transfer operations</strong>: one for <strong>invoking</strong> a coroutine and one for <strong>suspending</strong> it, the latter returning control to the coroutine invoker. While symmetric coroutines operate at the same hierarchical level, an asymmetric coroutine can be regarded as subordinate to its caller, the relationship between them being somewhat similar to that between a called and a calling routine.</p>
<p>– Revisit Coroutine, Ana Lúcia de Moura and Roberto Ierusalimschy</p>
</blockquote>
<p>从上面的定义看，<code>Kotlin coroutine</code>应该更像是<code>Symmetric coroutine</code>，下面是<code>Kotlin coroutine</code>官网的第一个样例，并没有<code>invoking</code>和<code>suspending</code>的接口，只有一个<code>launch</code>的接口来切换协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// non-blocking delay for 1 second (default time unit is ms)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        println(<span class="string">"World!"</span>) <span class="comment">// print after delay</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    println(<span class="string">"Hello,"</span>) <span class="comment">// main thread continues while coroutine is delayed</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// block main thread for 2 seconds to keep JVM alive</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="二、宏、接口与数据结构定义"><a href="#二、宏、接口与数据结构定义" class="headerlink" title="二、宏、接口与数据结构定义"></a>二、宏、接口与数据结构定义</h2><h3 id="1、宏与接口定义"><a href="#1、宏与接口定义" class="headerlink" title="1、宏与接口定义"></a>1、宏与接口定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C_COROUTINE_H</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_COROUTINE_H</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：协程的状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COROUTINE_DEAD 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COROUTINE_READY 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COROUTINE_RUNNING 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COROUTINE_SUSPEND 3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：协程调度器说明</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：协程执行函数指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*coroutine_func)</span><span class="params">(struct schedule *, <span class="keyword">void</span> *ud)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：创建调度器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="function">struct schedule * <span class="title">coroutine_open</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：关闭调度器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coroutine_close</span><span class="params">(struct schedule *)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：给调度器实例schedule创建协程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coroutine_new</span><span class="params">(struct schedule *, coroutine_func, <span class="keyword">void</span> *ud)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：恢复调度器实例schedule中协程id</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coroutine_resume</span><span class="params">(struct schedule *, <span class="keyword">int</span> id)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：查询调度器实例schedule中协程id的状态，返回值见上面协程的状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coroutine_status</span><span class="params">(struct schedule *, <span class="keyword">int</span> id)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：查询调度器实例schedule中运行的协程id</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coroutine_running</span><span class="params">(struct schedule *)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：出让调度器schedule中执行协程的执行权，并返回到main中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coroutine_yield</span><span class="params">(struct schedule *)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：定义调度器stack的大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024*1024)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// dpthinker说明：定义调度器中协程的默认数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_COROUTINE 16</span></span></pre></td></tr></table></figure>

<h3 id="2、数据结构定义"><a href="#2、数据结构定义" class="headerlink" title="2、数据结构定义"></a>2、数据结构定义</h3><p>调度器数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下注释为dpthinker追加</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">char</span> <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">// 当前协程的stack</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">ucontext_t</span> main; <span class="comment">// 主进程，没有初始化，一直为null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> nco; <span class="comment">// 当前coroutine的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> cap; <span class="comment">// 当前可以承载的coroutine最大容量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> <span class="built_in">running</span>; <span class="comment">// 当前运行的coroutine的id</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> **<span class="title">co</span>;</span> <span class="comment">// 所有coroutine示例的内存指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>协程数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下注释为dpthinker追加</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	coroutine_func func; <span class="comment">// 协程要调用的函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">void</span> *ud; <span class="comment">// 协程要调研函数的参数数据结构指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">ucontext_t</span> ctx; <span class="comment">// 本协程当前的上下文</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> * <span class="title">sch</span>;</span> <span class="comment">// 调度器实例指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">ptrdiff_t</span> cap; <span class="comment">// 协程栈的容量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">ptrdiff_t</span> <span class="built_in">size</span>; <span class="comment">// 协程栈的大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> status; <span class="comment">// 协程的运作状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">char</span> *<span class="built_in">stack</span>; <span class="comment">// 协程的栈指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<h2 id="三、协程初始化"><a href="#三、协程初始化" class="headerlink" title="三、协程初始化"></a>三、协程初始化</h2><h3 id="1、调度器初始化"><a href="#1、调度器初始化" class="headerlink" title="1、调度器初始化"></a>1、调度器初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> * </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">coroutine_open</span>(<span class="title">void</span>) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> *<span class="title">S</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">S</span>));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	S-&gt;nco = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	S-&gt;cap = DEFAULT_COROUTINE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	S-&gt;<span class="built_in">running</span> = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	S-&gt;co = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct coroutine *) * S-&gt;cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">memset</span>(S-&gt;co, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct coroutine *) * S-&gt;cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> S;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>malloc <code>schedule</code>对应的内存，并初始化<code>nco</code>、<code>cap</code>和<code>running</code>的状态</li>
<li>按<code>cap</code>的默认大小16，malloc 对应数量的<code>coroutine</code>指针内存</li>
</ul>
<h3 id="2、协程初始化"><a href="#2、协程初始化" class="headerlink" title="2、协程初始化"></a>2、协程初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class">_<span class="title">co_new</span>(<span class="title">struct</span> <span class="title">schedule</span> *<span class="title">S</span> , <span class="title">coroutine_func</span> <span class="title">func</span>, <span class="title">void</span> *<span class="title">ud</span>) &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * <span class="title">co</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">co</span>));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	co-&gt;func = func;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	co-&gt;ud = ud;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	co-&gt;sch = S;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	co-&gt;cap = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	co-&gt;<span class="built_in">size</span> = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	co-&gt;status = COROUTINE_READY;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	co-&gt;<span class="built_in">stack</span> = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> co;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>malloc <code>coroutine</code>的内存</li>
<li>初始化新获得<code>coroutine</code>实例中的变量，初始状态是<code>COROUTINE_READY</code></li>
</ul>
<h2 id="四、协程调度"><a href="#四、协程调度" class="headerlink" title="四、协程调度"></a>四、协程调度</h2><h3 id="1、-基础函数"><a href="#1、-基础函数" class="headerlink" title="1、 基础函数"></a>1、 基础函数</h3><p><code>cloudwu/coroutine</code>使用了Unix System V-like的context接口来实现栈的切换，主要使用到了<code>getcontext</code>、<code>makecontext</code>和<code>swapcontext</code>三个函数，其中关键的核心是<code>ucontext_t</code>的实例。</p>
<ul>
<li><code>ucontext_t</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">sigset_t</span>          uc_sigmask;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">stack_t</span>           uc_stack;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">mcontext_t</span>        uc_mcontext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">ucontext_t</span>;</span></pre></td></tr></table></figure>

<ul>
<li><p><code>int getcontext (ucontext_t *ucp)</code></p>
<blockquote>
<p>The getcontext function initializes the variable pointed to by ucp with the context of the calling thread. The context contains the content of the <code>registers</code>, the <code>signal mask</code>, and the <code>current stack</code>. Executing the contents would start at the point where the getcontext call just returned.</p>
</blockquote>
<p>获取当前运行的线程的<code>registers</code>、<code>signal mask</code>和<code>stack</code>。</p>
</li>
<li><p><code>void makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)</code></p>
<blockquote>
<p>The ucp parameter passed to the makecontext shall be initialized by a call to getcontext. The context will be modified to in a way so that if the context is resumed it will start by calling the function <code>func</code> which gets <code>argc</code> integer arguments passed. The integer arguments which are to be passed should follow the argc parameter in the call to makecontext.</p>
</blockquote>
<p>绑定<code>func</code>到通过<code>getcontext</code>获取到<code>ucontext_t</code>实例中，并且在被<code>resume</code>到的时候会去调用<code>func</code>。</p>
</li>
<li><p><code>int swapcontext (ucontext_t *restrict oucp, const ucontext_t *restrict ucp)</code></p>
<blockquote>
<p>The <code>swapcontext</code> function is similar to <code>setcontext</code> but instead of just replacing the current context the latter is first saved in the object pointed to by oucp as if this was a call to<code>getcontext</code>. The saved context would resume after the call to <code>swapcontext</code>.</p>
<p>Once the current context is saved the context described in ucp is installed and execution continues as described in this context.</p>
</blockquote>
<p>主要是交换上下文，暂停<code>oucp</code>，执行<code>ucp</code>。</p>
</li>
</ul>
<h3 id="2、invoking接口：coroutine-resume"><a href="#2、invoking接口：coroutine-resume" class="headerlink" title="2、invoking接口：coroutine_resume"></a>2、<code>invoking</code>接口：coroutine_resume</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">coroutine_resume(struct schedule * S, <span class="keyword">int</span> id) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	assert(S-&gt;<span class="built_in">running</span> == <span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	assert(id &gt;=<span class="number">0</span> &amp;&amp; id &lt; S-&gt;cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> *<span class="title">C</span> = <span class="title">S</span>-&gt;<span class="title">co</span>[<span class="title">id</span>];</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (C == <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> status = C-&gt;status;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">switch</span>(status) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">case</span> COROUTINE_READY:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">		getcontext(&amp;C-&gt;ctx);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">		C-&gt;ctx.uc_stack.ss_sp = S-&gt;<span class="built_in">stack</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">		C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">		C-&gt;ctx.uc_link = &amp;S-&gt;main;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">		S-&gt;<span class="built_in">running</span> = id;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">		C-&gt;status = COROUTINE_RUNNING;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>)S;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">		makecontext(&amp;C-&gt;ctx, (<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) mainfunc, <span class="number">2</span>, (<span class="keyword">uint32_t</span>)ptr, (<span class="keyword">uint32_t</span>)(ptr&gt;&gt;<span class="number">32</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">		swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">case</span> COROUTINE_SUSPEND:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">memcpy</span>(S-&gt;<span class="built_in">stack</span> + STACK_SIZE - C-&gt;<span class="built_in">size</span>, C-&gt;<span class="built_in">stack</span>, C-&gt;<span class="built_in">size</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">		S-&gt;<span class="built_in">running</span> = id;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">		C-&gt;status = COROUTINE_RUNNING;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">		swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">default</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">		assert(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>两种情况：</p>
<ul>
<li>协程刚被创建还没有参与过调度，当前状态是<code>COROUTINE_READY</code><ul>
<li>通过<code>getcontext</code>获取当前的<code>ucontext_t</code>赋值给新创建的协程<code>C</code></li>
<li>更新<code>C-&gt;ctx</code>的<code>uc_stack</code>的<code>ss_sp</code>和<code>ss_size</code>分别设为<code>S-&gt;stack</code>和<code>STACK_SIZE</code></li>
<li>更新<code>C-&gt;ctx</code>的<code>uc_link</code>为<code>&amp;S-&gt;main</code></li>
<li>更新调取器当前运行的协程<code>id</code></li>
<li>更新新创建的协程<code>C</code>的状态为<code>COROUTINE_RUNNING</code></li>
<li>将<code>mainfunc</code>挂靠到新创建的协程<code>C</code>中，并且以<code>S</code>指针为参数</li>
<li>切换到新创建的协程<code>C</code>的<code>ctx</code>，即运行<code>mainfunc</code>函数</li>
</ul>
</li>
<li>协程已经参与过调度，当前状态是<code>COROUTINE_SUSPEND</code><ul>
<li>将待切换<code>C</code>的栈内容拷贝到到调度<code>S</code>的栈中</li>
<li>更新调度器当前运行的协程<code>id</code></li>
<li>更新待切换的协程<code>C</code>的状态为<code>COROUTINE_RUNNING</code></li>
<li>切换到待切换的协程<code>C</code>，即继续执行<code>mainfunc</code>函数</li>
</ul>
</li>
</ul>
<p><code>mainfunc</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">mainfunc(<span class="keyword">uint32_t</span> low32, <span class="keyword">uint32_t</span> hi32) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>)low32 | ((<span class="keyword">uintptr_t</span>)hi32 &lt;&lt; <span class="number">32</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> *<span class="title">S</span> = (<span class="title">struct</span> <span class="title">schedule</span> *)<span class="title">ptr</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> id = S-&gt;<span class="built_in">running</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> *<span class="title">C</span> = <span class="title">S</span>-&gt;<span class="title">co</span>[<span class="title">id</span>];</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	C-&gt;func(S,C-&gt;ud);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	_co_delete(C);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	S-&gt;co[id] = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	--S-&gt;nco;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	S-&gt;<span class="built_in">running</span> = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>主要做了以下工作：</p>
<ul>
<li>获取当前运行的协程<code>id</code></li>
<li>执行该协程的<code>func</code>函数，参数为<code>ud</code></li>
<li>执行完<code>func</code>后，删除销毁该协程<code>C</code></li>
<li>清理调度器<code>S</code>中的参数，设置当前运行的协程<code>id</code>为-1</li>
</ul>
<p>总结：<code>void coroutine_resume(struct schedule *, int id)</code>实现了协程的栈和上下文<code>ucontext_t</code>的切换，并切换到协程<code>id</code>执行<code>func</code>函数或者继续执行上次暂停的<code>func</code>函数。</p>
<h3 id="3、suspending接口：coroutine-yield"><a href="#3、suspending接口：coroutine-yield" class="headerlink" title="3、suspending接口：coroutine_yield"></a>3、<code>suspending</code>接口：coroutine_yield</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">coroutine_yield(struct schedule * S) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> id = S-&gt;<span class="built_in">running</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	assert(id &gt;= <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * <span class="title">C</span> = <span class="title">S</span>-&gt;<span class="title">co</span>[<span class="title">id</span>];</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	assert((<span class="keyword">char</span> *)&amp;C &gt; S-&gt;<span class="built_in">stack</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	_save_stack(C,S-&gt;<span class="built_in">stack</span> + STACK_SIZE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	C-&gt;status = COROUTINE_SUSPEND;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	S-&gt;<span class="built_in">running</span> = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	swapcontext(&amp;C-&gt;ctx , &amp;S-&gt;main);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">_save_stack(struct coroutine *C, <span class="keyword">char</span> *top) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">char</span> dummy = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	assert(top - &amp;dummy &lt;= STACK_SIZE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (C-&gt;cap &lt; top - &amp;dummy) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">free</span>(C-&gt;<span class="built_in">stack</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		C-&gt;cap = top-&amp;dummy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">		C-&gt;<span class="built_in">stack</span> = <span class="built_in">malloc</span>(C-&gt;cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	C-&gt;<span class="built_in">size</span> = top - &amp;dummy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">memcpy</span>(C-&gt;<span class="built_in">stack</span>, &amp;dummy, C-&gt;<span class="built_in">size</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>主要完成了以下工作：</p>
<ul>
<li><p>获取当前运行的协程</p>
</li>
<li><p>将调度器的栈保存到协程中，注：<strong>这里的地址<code>dummy</code>地址为0，不清楚是怎么拷贝的？</strong></p>
</li>
<li><p>将当前运行的协程的状态置为<code>COROUTINE_SUSPEND</code>，调度器中当前运行的协程<code>id</code>设为-1</p>
</li>
<li><p>切换到上下文到<code>S-&gt;main</code>，继续执行主进程的工作</p>
<p>注：姑且把把主干流程的称之为主进程</p>
</li>
</ul>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><ul>
<li><code>coroutine_resume</code>的工作是从主进程的切到指定协程</li>
<li><code>coroutine_yield</code>的工作是同当前运行的协程切到主进程</li>
<li>各个协程之间没有直接的切换，需要通过主进程作为中介</li>
</ul>
<h2 id="五、协程资源释放"><a href="#五、协程资源释放" class="headerlink" title="五、协程资源释放"></a>五、协程资源释放</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">coroutine_close(struct schedule *S) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;S-&gt;cap;i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * <span class="title">co</span> = <span class="title">S</span>-&gt;<span class="title">co</span>[<span class="title">i</span>];</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> (co) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">			_co_delete(co);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">free</span>(S-&gt;co);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	S-&gt;co = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">free</span>(S);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">_co_delete(struct coroutine *co) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">free</span>(co-&gt;<span class="built_in">stack</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">free</span>(co);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>coroutine_close</code>会循环遍历调度器<code>S</code>中所有的协程并释放之，最终还会释放<code>S</code>本身。</p>
<h2 id="六、协程运行效果"><a href="#六、协程运行效果" class="headerlink" title="六、协程运行效果"></a>六、协程运行效果</h2><p>定义协程要运行的函数和参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">foo(struct schedule * S, <span class="keyword">void</span> *ud) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> * <span class="title">arg</span> = <span class="title">ud</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> start = arg-&gt;n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// dpthinker说明：5次打印日志，每次对start递加1，并出让到主进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">printf</span>(<span class="string">"coroutine %d : %d, in tid %d\n"</span>,coroutine_running(S) , start + i,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">               pthread_self());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">		coroutine_yield(S); <span class="comment">// dpthinker说明：从当前协程切到主进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">test(struct schedule *S) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">arg1</span> = &#123;</span> <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">arg2</span> = &#123;</span> <span class="number">100</span> &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> co1 = coroutine_new(S, foo, &amp;arg1); <span class="comment">// dpthinker说明：创建协程co1，即函数foo，参数0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> co2 = coroutine_new(S, foo, &amp;arg2); <span class="comment">// dpthinker说明：创建协程co2，即函数foo，参数100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">printf</span>(<span class="string">"main start\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// dpthinker说明：循环检查协程co1和co2的状态是否处于激活状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">while</span> (coroutine_status(S,co1) &amp;&amp; coroutine_status(S,co2)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">		coroutine_resume(S,co1); <span class="comment">// dpthinker说明：恢复调度协程co1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">		coroutine_resume(S,co2); <span class="comment">// dpthinker说明：恢复调度协程co2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	&#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">printf</span>(<span class="string">"main end\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">main() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> * <span class="title">S</span> = <span class="title">coroutine_open</span>();</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	test(S);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	coroutine_close(S);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">➜  coroutine git:(master) ✗ ./main </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">main start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">coroutine 0 : 0, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">coroutine 1 : 100, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">coroutine 0 : 1, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">coroutine 1 : 101, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">coroutine 0 : 2, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">coroutine 1 : 102, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">coroutine 0 : 3, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">coroutine 1 : 103, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">coroutine 0 : 4, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">coroutine 1 : 104, in tid 140633448457472</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">main end</span></pre></td></tr></table></figure>

<p>可见，在同一个线程中，<code>coroutine</code>1和2交替的执行，分别从0和100交替递增到了4和104。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><a href="https://github.com/cloudwu" target="_blank" rel="noopener">cloudwu</a>/<strong><a href="https://github.com/cloudwu/coroutine" target="_blank" rel="noopener">coroutine</a></strong>通过Unix System V的context接口，通过<strong>切换栈</strong>和<strong>上下文</strong>信息，实现了极简的<code>Asymmetric coroutine</code>。</p>
<p>下图总结了协程调度的主要流程：</p>
<p><img src="/images/co-example.png" alt="image-20200307210105087"></p>
<p>简单总结如下：</p>
<ul>
<li>通过<code>coroutine_resume</code>接口可以在主进程中切到协程<code>co1</code>的上下文</li>
<li>协程<code>co1</code>执行过程中可以通过接口<code>coroutine_yield</code>切到主进程</li>
<li>主进程可以继续通过<code>coroutine_resume</code>切换到其他的协程<code>co2</code>、<code>co3</code>、…<code>coN</code>。</li>
</ul>
<h2 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h2><p><a href="https://blog.codingnow.com/2012/07/c_coroutine.html" target="_blank" rel="noopener">https://blog.codingnow.com/2012/07/c_coroutine.html</a></p>
<p><a href="https://github.com/cloudwu/coroutine" target="_blank" rel="noopener">https://github.com/cloudwu/coroutine</a></p>
<p><a href="https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines" target="_blank" rel="noopener">https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines</a></p>
<p><a href="http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf" target="_blank" rel="noopener">Revisiting Coroutine</a></p>
<p><a href="https://kotlinlang.org/docs/reference/coroutines/basics.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/coroutines/basics.html</a></p>
<p><a href="http://man7.org/linux/man-pages/man3/getcontext.3.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man3/getcontext.3.html</a></p>
<p><a href="http://man7.org/linux/man-pages/man3/makecontext.3.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man3/makecontext.3.html</a></p>
<p><a href="https://ftp.gnu.org/old-gnu/Manuals/glibc/html_node/System-V-contexts.html" target="_blank" rel="noopener">https://ftp.gnu.org/old-gnu/Manuals/glibc/html_node/System-V-contexts.html</a></p>
<p><a href="https://github.com/zfengzhen/Blog/blob/master/article/ucontext簇函数学习.md" target="_blank" rel="noopener">https://github.com/zfengzhen/Blog/blob/master/article/ucontext%E7%B0%87%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0.md</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/协程-编程语言/">协程,编程语言</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comment" class="comment">
		<div id="gitalk-container"></div>
	</section>
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
	<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script>
		var gitalk = new Gitalk({
			clientID: '288f10c4e81476750987',
			clientSecret: '30d0e1f5ab6ccb5599d3f9102e3ad2e2fee72995',
			repo: 'dpinthinker.github.io',
			owner: 'dpinthinker',
			admin: ['dpinthinker'],
			id: location.pathname,
			distractionFreeMode: false
		})

		gitalk.render('gitalk-container')
	</script>







    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 dpthinker
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>